### staleTime

쿼리 데이터를 처음 `fetch`한 시점을 기준으로 그 **데이터를 "신선한 상태"로 간주하는** 시간이다.

`staleTime` 동안에는 같은 쿼리에 대한 새로운 네트워크 요청이 일어나지 않고, 캐시된 데이터를 그대로 사용한다. 즉, 이 시간 동안에는 `자동 refetch(revalidate)`가 트리거 되어도 네트워크 요청을 보내지 않는다. 이 시간은 컴포넌트가 언마운트되어도 상관없이 계속 흘러감.

`staleTime`이 지난 후부터 데이터는 `stale(오래된)` 상태가 된다.

하지만 `staleTime`이 지나더라도

- `자동 refetch(revalidate) 트리거` (ex. 페이지 방문하여 윈도우 포커스, 네트워크 복구, 쿼리 마운트 등)가 발생하지 않고
- `수동 refetch`도 실행하지 않으면

여전히 캐시된 데이터를 사용할 수 있다. (== 데이터가 `stale` 상태가 됐다고 해서 바로 데이터를 `fetch` 하지 않음) <br>
이 캐시 데이터는 새로운 요청을 보내 신선한 데이터를 받아오기 전에 기존 데이터를 임시로 표시하는데 활용된다.

`staleTime`이 지난 후 자동 / 수동 `refetch`가 트리거된다면 새로운 요청을 보내면 데이터를 갱신하게 된다. <br>
(수동 `refetch`는 `staleTime`과 상관없이 무조건 네트워크 요청을 발생시켜 서버 최신 데이터를 가져온다. 이 경우, 기존 캐시를 덮어쓰고 최신 데이터를 저장한다.)

`staleTime`의 기본값은 0이다.

<br>

### gcTime

**해당 쿼리를 사용하는 곳이 없게 된 이후(컴포넌트 언마운트)에도 캐시 데이터를 메모리에 얼마 동안 더 보관할지**를 정하는 시간이다.

여러 컴포넌트에서 같은 쿼리 `queryKey`를 `useQuery`로 구독하고 있을 수 있다. <br>
만약 이 컴포넌트가 모두 언마운트되어, 더 이상 어떤 컴포넌트도 이 쿼리를 구독하고 있지 않게 된다면 <br>
이 순간부터 `gcTime`의 타이머가 동작하고 **`gcTime`이 지나면 메모리에서도 해당 캐시 데이터가 삭제**된다.

예시

1. 페이지A, 페이지B 모두에서 `useQuery(['user'])`를 사용

2. 사용자가 페이지A, 페이지B 모두를 떠나서, 어느 곳에서도 `useQuery(['user'])`가 마운트되어 있지 않은 시점이 되면

3. 이 시점부터 `gcTime` 카운트다운 시작

4. `gcTime`이 지나면 해당 캐시 데이터가 삭제

<br>

`gcTime`의 기본값은 5분이다.

<br>

## 정리

`staleTime`은 **데이터를 처음 가져온 시점을 기준으로, 얼마나 이 데이터를 신선한 상태로 유지할 것인지**에 대한 시간이다. <br>
`staleTime`이 지나면 데이터는 신선하지 않은 `stale` 상태가 되지만, 자동 / 수동 `refetch` 트리거가 없다면 이 캐시된 `stale`한 데이터를 계속 사용할 수 있다.

`gcTime`은 `staleTime`과는 별개로 동작한다. <br>
`gcTime` 타이머는 **"해당 쿼리를 구독하고 있는 모든 컴포넌트가 언마운트된 시점"** 부터 시작하며, **데이터가 `fresh` 상태든 `stale` 상태든 상관없이 동작한다.**

<br>

---

#### 래퍼런스

- https://www.maeil-mail.kr/question/5
