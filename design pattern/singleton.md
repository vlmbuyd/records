## 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴.

인스턴스가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고, 최초 생성 이후에 호출된 인스턴스는 최초의 인스턴스가 생성한 객체를 리턴한다.

자바스크립트에서 리터럴 `{}` 또는 `new Object`로 객체를 생성하면 다른 어떤 객체와도 같지 않기 때문에 이 자체만으로 싱글톤 패턴을 구현할 수 있다.

**싱글톤 패턴 (객체 리터럴)**

```js
const obj = {
  a: 27,
};

const obj2 = {
  a: 27,
};

console.log(obj === obj2); // false
// obj와 obj2는 다른 인스턴스를 가짐
```

하지만 **객체 그 자체가 싱글톤 패턴은 아니다**.<br>
(객체 리터럴은 한 번 만들어진 "값"일 뿐, 다른 새로운 객체를 만들 수 있기 때문에)

**싱글톤 패턴 (클래스)**

```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }

  getInstance() {
    return this.instance;
  }

  const a = new Singleton()
  const b = new Singleton()
  console.log(a === b) // true

}
```

<br>

### 장점 및 단점

싱글톤 패턴의 장점으로는 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하도록 하기 때문에 **인스턴스를 생성할 때 드는 비용이 줄어든다**(메모리 절약)는 점이다.

하지만 인스턴스를 하나만 만들도록 강제하기 때문에 한정된 메모리를 사용할 수 밖에 없고 의존성이 높아진다는 단점이 있고, 전역 인스턴스로써 자원을 공유하기에 독립적인 환경에서 테스트를 수행하기에 제약이 있다.

<br>

### 전역 상태 관리

싱글톤 패턴으로 만들어진 객체나 인스턴스는 모든 곳에서 동일한 인스턴스를 참조하기 때문에,
그 인스턴스의 값을 한 곳에서 변경하면 그 값을 공유하는 모든 코드에서 변경된 값이 바로 반영된다.

따라서 싱글톤 패턴은 흔히 "앱의 전역 상태 관리" 용도로 사용된다.

하지만 최근 자바스크립트의 기조는 원활한 데이트 흐름 파악을 위해 **전역 상태의 사용을 지양**하는 방향으로 발전되고 있다. (var 대신 let/const 사용, 모듈 시스템 도입 import/export)

React에선 전역 상태관리를 위해 싱글톤 객체를 만드는 대신 `Redux`나 `React Context`를 사용한다. 싱글톤 패턴이 인스턴스의 값을 직접 수정할 수 있는 반면, 언급한 상태 관리 도구들은 **읽기 전용 상태**를 제공하여 컴포넌트가 직접 상태를 업데이트 하는 것을 방지한다.

<br>

### React의 상태 관리 도구들이 "읽기 전용 상태"를 제공하는 이유

1. **예측 가능한 상태 변화**

   상태가 직접 수정되지 않고 특정한 함수, 액션 등을 통해서 변경되면 언제, 어디서, 어떤 이유로 상태가 바뀌었는지 추적 및 예측이 쉽다.

2. **컴포넌트 렌더링 일관성 보장**

   상태를 직접 변경하면 React 자체적으로 변경을 감지하지 못하고 화면에 변경 사항이 반영되지 못하는 경우가 생김 (ex. 객체의 속성을 직접 바꿔버리는 경우 )

    <br>
    
   **React는 상태가 바뀌었는지 어떻게 알까?**

   React는 상태 변수의 참조값이 바뀌었는지를 보고 변경여부를 판단함.

   ```js
   const [user, setUser] = useState({ name: "Kim", age: 20 });

   // (잘못된 예시)
   user.age = 21; // 객체의 속성만 바꿈!
   ```

   하지만 이런 식으로 변경 함수를 거치지 않고 직접 객체의 값을 변경하게 되면, **참조값은 그대로고 내부 값만 바뀌게되므로** React는 user가 여전히 같은 객체라고 생각하여 변경을 감지하지 못함

   따라서 객체의 상태를 변경할 때는 **"새 객체"를 만들어 할당**해야 React가 상태 변경을 감지할 수 있음

   ```js
   // 올바른 방법
   setUser({ ...user, age: 21 }); // 새 객체 생성!
   ```

<br>

따라서, `읽기 전용 + setter 함수` 구조를 사용하면 상태 변화를 정확하게 감지하고, 필요한 컴포넌트만 효율적으로 다시 렌더링할 수 있음

<br>

### 모듈 방식 싱글톤 vs 전통적인 싱글톤

- **모듈 방식**

  - 한 번만 실행되고, import하는 모든 곳에서 같은 인스턴스를 공유함
  - 모듈 시스템(ESM, CommonJS)의 캐싱 덕분에 싱글톤처럼 쓸수 있음

  하지만, 싱글톤과 유사하게 동작할 뿐, JS 엔진 레벨에서 인스턴스를 강제적으로 막는 구조는 아님.

- **전통적인 싱글톤**

  - 클래스 레벨에서 인스턴스가 단 하나만 만들어지도록 "강제"하는 디자인 패턴
  - 생성자를 `private`로 만들거나, `getInstance`같은 메소드를 통해 외부에서 직접 인스턴스 생성 자체를 차단함.

  “설계적으로 하나만 만든다”는 걸 코드(클래스 내부 로직)로 명확하게 보장함.

#### 래퍼런스

- https://velog.io/@june_summer/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4
- https://patterns-dev-kr.github.io/design-patterns/singleton-pattern/
